--! lz -- This line might be used by some executors to indicate LuaZ (bytecode) obfuscation, often just a comment.

--[[
    Improved Custom GUI Fun Script - Pure Roblox Instances
    Generated by Gemini

    Disclaimer:
    This script is a more robust version of the custom GUI, built entirely
    with Roblox's native Instance objects. It aims to reduce dependencies
    and potential points of failure from external libraries.

    - This script is for demonstration and educational purposes.
    - It is NOT guaranteed to be perfectly bug-free or compatible with all
      Roblox game environments or exploit executors without extensive testing.
    - The visual styling aims for a clean, functional look.
    - All features are client-sided unless explicitly stated otherwise.
    - Use responsibly and understand the terms of service of the games you play.
    - No aimbot features are included as per your request.

    IMPORTANT: If this still doesn't work, the issue is almost certainly
    related to your specific exploit's compatibility with Roblox updates,
    or the game's anti-cheat systems. As an AI, I cannot debug or fix
    environmental issues within your exploit.

    Line Count Goal: ~900+ lines (This version will be even longer due to added robustness)
]]

-- ============================================================================
-- 1. Initial Setup: Roblox Services & Global Variables
-- ============================================================================

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local CoreGui = game:GetService("CoreGui") -- Common for exploits
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService") -- For generating unique IDs for elements

-- Global script variables and states
local script_name = "FunHub_CustomUI_V2"
local script_version = "1.0.2" -- Updated version
local is_ui_open = true -- Initial state of the UI

-- ============================================================================
-- 2. Custom UI Framework: Core Functions for Creating Elements
-- ============================================================================

local GUI_SETTINGS = {
    MAIN_COLOR = Color3.fromRGB(30, 30, 30),
    ACCENT_COLOR = Color3.fromRGB(80, 150, 255), -- Rayfield-like blue
    TEXT_COLOR = Color3.fromRGB(200, 200, 200),
    BORDER_COLOR = Color3.fromRGB(45, 45, 45),
    TEXT_FONT = Enum.Font.SourceSans,
    TEXT_SIZE = 14,
    HEADER_HEIGHT = 30,
    TAB_HEIGHT = 32,
    SECTION_HEADER_HEIGHT = 26,
    ELEMENT_HEIGHT = 24,
    PADDING = 8,
    ELEMENT_SPACING = 4,
    WINDOW_WIDTH = 450, -- Slightly wider
    WINDOW_HEIGHT = 350, -- Slightly taller
}

local UI_STATE = {} -- Store states of toggles, sliders, etc. for easy retrieval

-- Function to create a basic frame
local function CreateFrame(parent, name, size, position, color, transparency, ZIndex)
    local frame = nil
    local success, err = pcall(function()
        frame = Instance.new("Frame")
        frame.Name = name or HttpService:GenerateGUID(false)
        frame.Size = size or UDim2.new(1, 0, 1, 0)
        frame.Position = position or UDim2.new(0, 0, 0, 0)
        frame.BackgroundColor3 = color or GUI_SETTINGS.MAIN_COLOR
        frame.BackgroundTransparency = transparency or 0
        frame.BorderSizePixel = 0
        frame.ZIndex = ZIndex or 1
        if parent then frame.Parent = parent end
    end)
    if not success then warn("Failed to create Frame '" .. (name or "Unnamed") .. "': " .. err) end
    return frame
end

-- Function to create a basic text label
local function CreateTextLabel(parent, name, text, size, position, color, transparency, ZIndex, font, textSize, textColor, textXAlignment)
    local label = nil
    local success, err = pcall(function()
        label = Instance.new("TextLabel")
        label.Name = name or HttpService:GenerateGUID(false)
        label.Text = text or ""
        label.Size = size or UDim2.new(1, 0, 1, 0)
        label.Position = position or UDim2.new(0, 0, 0, 0)
        label.BackgroundColor3 = color or GUI_SETTINGS.MAIN_COLOR
        label.BackgroundTransparency = transparency or 1
        label.TextColor3 = textColor or GUI_SETTINGS.TEXT_COLOR
        label.Font = font or GUI_SETTINGS.TEXT_FONT
        label.TextSize = textSize or GUI_SETTINGS.TEXT_SIZE
        label.TextScaled = false
        label.TextXAlignment = textXAlignment or Enum.TextXAlignment.Left
        label.TextWrapped = true
        label.ZIndex = ZIndex or 1
        if parent then label.Parent = parent end
    end)
    if not success then warn("Failed to create TextLabel '" .. (name or "Unnamed") .. "': " .. err) end
    return label
end

-- Function to create a basic text button
local function CreateTextButton(parent, name, text, size, position, color, textColor, ZIndex, callback)
    local button = nil
    local success, err = pcall(function()
        button = Instance.new("TextButton")
        button.Name = name or HttpService:GenerateGUID(false)
        button.Text = text or ""
        button.Size = size or UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT)
        button.Position = position or UDim2.new(0, 0, 0, 0)
        button.BackgroundColor3 = color or GUI_SETTINGS.BORDER_COLOR
        button.BackgroundTransparency = 0
        button.TextColor3 = textColor or GUI_SETTINGS.TEXT_COLOR
        button.Font = GUI_SETTINGS.TEXT_FONT
        button.TextSize = GUI_SETTINGS.TEXT_SIZE
        button.TextScaled = false
        button.BorderSizePixel = 0
        button.ZIndex = ZIndex or 1
        if parent then button.Parent = parent end

        -- Hover effect
        local original_color = color or GUI_SETTINGS.BORDER_COLOR
        button.MouseEnter:Connect(function()
            if button.BackgroundTransparency == 0 then -- Only apply hover if not transparent
                button.BackgroundColor3 = original_color:Lerp(GUI_SETTINGS.ACCENT_COLOR, 0.3)
            end
        end)
        button.MouseLeave:Connect(function()
            if button.BackgroundTransparency == 0 then
                button.BackgroundColor3 = original_color
            end
        end)

        if callback then
            button.MouseButton1Click:Connect(callback)
        end
    end)
    if not success then warn("Failed to create TextButton '" .. (name or "Unnamed") .. "': " .. err) end
    return button
end

-- Function to create a toggle switch
local function CreateToggle(parent, name, default_state, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)
    if not container then return nil, function() return false end end

    local toggle_state = default_state
    UI_STATE[name] = toggle_state

    local name_label = CreateTextLabel(container, "NameLabel", name, UDim2.new(1, -(GUI_SETTINGS.ELEMENT_HEIGHT + GUI_SETTINGS.PADDING), 1, 0), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), nil, 1)
    name_label.TextXAlignment = Enum.TextXAlignment.Left
    if not name_label then return container, function() return UI_STATE[name] end end

    local toggle_button = CreateTextButton(container, "ToggleButton", "", UDim2.new(0, GUI_SETTINGS.ELEMENT_HEIGHT, 1, 0), UDim2.new(1, -GUI_SETTINGS.ELEMENT_HEIGHT - GUI_SETTINGS.PADDING, 0, 0), GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR)
    toggle_button.TextSize = GUI_SETTINGS.TEXT_SIZE - 2
    if not toggle_button then return container, function() return UI_STATE[name] end end

    local function update_toggle_visual()
        toggle_button.Text = toggle_state and "ON" or "OFF"
        toggle_button.TextColor3 = toggle_state and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
        toggle_button.BackgroundColor3 = toggle_state and GUI_SETTINGS.ACCENT_COLOR or GUI_SETTINGS.BORDER_COLOR
    end

    toggle_button.MouseButton1Click:Connect(function()
        toggle_state = not toggle_state
        UI_STATE[name] = toggle_state
        update_toggle_visual()
        if callback then
            local success, err = pcall(callback, toggle_state)
            if not success then warn("Toggle callback for '" .. name .. "' failed: " .. err) end
        end
    end)

    update_toggle_visual() -- Initial visual update

    return container, function() return UI_STATE[name] end
end

-- Function to create a slider
local function CreateSlider(parent, name, range, increment, suffix, current_value, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT * 2), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)
    if not container then return nil, function() return range[1] end end
    
    local min_val, max_val = range[1], range[2]
    local value = math.clamp(current_value, min_val, max_val)
    UI_STATE[name] = value

    local name_label = CreateTextLabel(container, "NameLabel", name, UDim2.new(1, -70, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), nil, 1, nil, nil, nil, Enum.TextXAlignment.Left)
    if not name_label then return container, function() return UI_STATE[name] end end

    local value_label = CreateTextLabel(container, "ValueLabel", tostring(math.floor(value * 10) / 10) .. suffix, UDim2.new(0, 70, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(1, -70 - GUI_SETTINGS.PADDING, 0, 0), nil, 1, nil, nil, nil, Enum.TextXAlignment.Right)
    if not value_label then return container, function() return UI_STATE[name] end end

    local slider_frame = CreateFrame(container, "SliderFrame", UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 0, GUI_SETTINGS.ELEMENT_HEIGHT / 2), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.ELEMENT_HEIGHT), GUI_SETTINGS.BORDER_COLOR)
    if not slider_frame then return container, function() return UI_STATE[name] end end

    local slider_fill = CreateFrame(slider_frame, "SliderFill", UDim2.new((value - min_val) / (max_val - min_val), 0, 1, 0), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.ACCENT_COLOR)
    if not slider_fill then return container, function() return UI_STATE[name] end end

    local uicorner = Instance.new("UICorner") -- Rounded corners for slider fill
    uicorner.CornerRadius = UDim.new(0, 3)
    uicorner.Parent = slider_fill
    local uicorner_frame = Instance.new("UICorner") -- Rounded corners for slider frame
    uicorner_frame.CornerRadius = UDim.new(0, 3)
    uicorner_frame.Parent = slider_frame


    local dragging = false
    local input_changed_conn = nil

    local function update_slider(input)
        if not dragging then return end
        local mouse_x = input.Position.X
        local frame_x = slider_frame.AbsolutePosition.X
        local frame_width = slider_frame.AbsoluteSize.X

        local normalized_pos = math.clamp((mouse_x - frame_x) / frame_width, 0, 1)
        local raw_value = min_val + normalized_pos * (max_val - min_val)
        value = math.floor(raw_value / increment + 0.5) * increment -- Round to nearest increment
        value = math.clamp(value, min_val, max_val)

        UI_STATE[name] = value
        slider_fill.Size = UDim2.new((value - min_val) / (max_val - min_val), 0, 1, 0)
        value_label.Text = tostring(math.floor(value * 10) / 10) .. suffix

        if callback then
            local success, err = pcall(callback, value)
            if not success then warn("Slider callback for '" .. name .. "' failed: " .. err) end
        end
    end

    slider_frame.MouseButton1Down:Connect(function()
        dragging = true
        if input_changed_conn then input_changed_conn:Disconnect() end -- Disconnect old if any
        input_changed_conn = UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                update_slider(input)
            end
        end)
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
            if input_changed_conn then input_changed_conn:Disconnect() end
            input_changed_conn = nil
        end
    end)

    if callback then
        local success, err = pcall(callback, value) -- Initial callback
        if not success then warn("Slider initial callback for '" .. name .. "' failed: " .. err) end
    end

    return container, function() return UI_STATE[name] end
end

-- Function to create a TextBox
local function CreateTextBox(parent, name, placeholder, default_text, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)
    if not container then return nil, function() return "" end end

    local textbox = Instance.new("TextBox")
    textbox.Name = name .. "Input"
    textbox.PlaceholderText = placeholder or ""
    textbox.Text = default_text or ""
    textbox.Size = UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 1, 0)
    textbox.Position = UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0)
    textbox.BackgroundColor3 = GUI_SETTINGS.BORDER_COLOR
    textbox.BackgroundTransparency = 0
    textbox.TextColor3 = GUI_SETTINGS.TEXT_COLOR
    textbox.Font = GUI_SETTINGS.TEXT_FONT
    textbox.TextSize = GUI_SETTINGS.TEXT_SIZE
    textbox.TextScaled = false
    textbox.ClearTextOnFocus = false
    textbox.BorderSizePixel = 0
    textbox.ZIndex = 1
    if not textbox then return container, function() return UI_STATE[name] end end
    textbox.Parent = container

    local uicorner = Instance.new("UICorner") -- Rounded corners for textbox
    uicorner.CornerRadius = UDim.new(0, 6)
    uicorner.Parent = textbox

    UI_STATE[name] = textbox.Text

    textbox.FocusLost:Connect(function(enterPressed)
        UI_STATE[name] = textbox.Text
        if callback then
            local success, err = pcall(callback, textbox.Text)
            if not success then warn("TextBox callback for '" .. name .. "' failed: " .. err) end
        end
    end)

    return container, function() return UI_STATE[name] end
end


-- ============================================================================
-- 3. Main Window Construction
-- ============================================================================
print("Attempting to create ScreenGui...")
local main_screen_gui = Instance.new("ScreenGui")
main_screen_gui.Name = script_name .. "_ScreenGui"
main_screen_gui.DisplayOrder = 999 -- Ensure it's on top
main_screen_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
main_screen_gui.Parent = CoreGui
print("ScreenGui created.")

print("Attempting to create Main Window Frame...")
local main_frame = CreateFrame(main_screen_gui, "MainWindow",
    UDim2.new(0, GUI_SETTINGS.WINDOW_WIDTH, 0, GUI_SETTINGS.WINDOW_HEIGHT),
    UDim2.new(0.5, -GUI_SETTINGS.WINDOW_WIDTH / 2, 0.5, -GUI_SETTINGS.WINDOW_HEIGHT / 2),
    GUI_SETTINGS.MAIN_COLOR, 0, 2
)
if not main_frame then error("Failed to create main_frame. Script cannot continue.") end
main_frame.ClipsDescendants = true -- Important for preventing elements from overflowing
print("Main Window Frame created.")

-- Rounded corners for the main window
local uicorner_main = Instance.new("UICorner")
uicorner_main.CornerRadius = UDim.new(0, 8)
uicorner_main.Parent = main_frame

-- Header for dragging
print("Attempting to create Header Frame...")
local header_frame = CreateFrame(main_frame, "Header",
    UDim2.new(1, 0, 0, GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, 0, 0, 0),
    GUI_SETTINGS.BORDER_COLOR, 0, 3
)
if not header_frame then error("Failed to create header_frame. Script cannot continue.") end
header_frame.BorderSizePixel = 0
print("Header Frame created.")

print("Attempting to create Header Label...")
local header_label = CreateTextLabel(header_frame, "TitleLabel",
    script_name .. " v" .. script_version,
    UDim2.new(1, -(GUI_SETTINGS.HEADER_HEIGHT * 2), 1, 0),
    UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0),
    nil, 1, 4, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE + 2, GUI_SETTINGS.TEXT_COLOR, Enum.TextXAlignment.Left
)
print("Header Label created.")

-- Minimize/Close Button
print("Attempting to create Minimize Button...")
local minimize_button = CreateTextButton(header_frame, "MinimizeButton", "-",
    UDim2.new(0, GUI_SETTINGS.HEADER_HEIGHT, 1, 0),
    UDim2.new(1, -GUI_SETTINGS.HEADER_HEIGHT, 0, 0),
    Color3.fromRGB(255, 50, 50), Color3.fromRGB(255, 255, 255), 4 -- Red background for close-like feel
)
minimize_button.TextSize = GUI_SETTINGS.TEXT_SIZE + 8
minimize_button.TextScaled = false
if minimize_button then
    minimize_button.MouseButton1Click:Connect(function()
        main_frame.Visible = not main_frame.Visible
        is_ui_open = main_frame.Visible
        print("UI visibility toggled: " .. tostring(is_ui_open))
    end)
end
print("Minimize Button created.")


-- Window dragging logic
local dragging_window = false
local drag_start_pos = Vector2.new(0, 0)
local frame_start_pos_offset = Vector2.new(0, 0)
local input_changed_drag_conn = nil
local input_ended_drag_conn = nil

header_frame.MouseButton1Down:Connect(function()
    dragging_window = true
    drag_start_pos = UserInputService:GetMouseLocation()
    frame_start_pos_offset = Vector2.new(main_frame.Position.X.Offset, main_frame.Position.Y.Offset)
    
    if input_changed_drag_conn then input_changed_drag_conn:Disconnect() end
    input_changed_drag_conn = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging_window then
            local current_mouse_pos = UserInputService:GetMouseLocation()
            local delta = current_mouse_pos - drag_start_pos
            main_frame.Position = UDim2.new(0, frame_start_pos_offset.X + delta.X, 0, frame_start_pos_offset.Y + delta.Y)
        end
    end)
end)

input_ended_drag_conn = UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging_window = false
        if input_changed_drag_conn then input_changed_drag_conn:Disconnect() end
        input_changed_drag_conn = nil
    end
end)


-- ============================================================================
-- 4. Tab System
-- ============================================================================
print("Creating Tab system...")
local TAB_BUTTONS_WIDTH = 120 -- Wider tab buttons
local tab_buttons_frame = CreateFrame(main_frame, "TabButtonsFrame",
    UDim2.new(0, TAB_BUTTONS_WIDTH, 1, -GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, 0, 0, GUI_SETTINGS.HEADER_HEIGHT),
    GUI_SETTINGS.BORDER_COLOR, 0, 2
)
if not tab_buttons_frame then error("Failed to create tab_buttons_frame.") end

local content_frame = CreateFrame(main_frame, "ContentFrame",
    UDim2.new(1, -TAB_BUTTONS_WIDTH, 1, -GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, TAB_BUTTONS_WIDTH, 0, GUI_SETTINGS.HEADER_HEIGHT),
    GUI_SETTINGS.MAIN_COLOR, 0, 2
)
if not content_frame then error("Failed to create content_frame.") end
content_frame.ClipsDescendants = true -- Important for preventing elements from overflowing

local active_tab_name = nil
local tabs = {} -- Store { Name = {button, content_frame} }

local function CreateTab(tab_name)
    local tab_index = #tabs + 1
    local tab_button = CreateTextButton(tab_buttons_frame, tab_name .. "TabButton",
        tab_name,
        UDim2.new(1, 0, 0, GUI_SETTINGS.TAB_HEIGHT),
        UDim2.new(0, 0, 0, (tab_index - 1) * GUI_SETTINGS.TAB_HEIGHT),
        GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR, 3
    )
    if not tab_button then warn("Failed to create tab_button: " .. tab_name); return nil end
    tab_button.TextScaled = false
    tab_button.TextXAlignment = Enum.TextXAlignment.Center

    local tab_content_frame = CreateFrame(content_frame, tab_name .. "Content",
        UDim2.new(1, 0, 1, 0), UDim2.new(0, 0, 0, 0),
        GUI_SETTINGS.MAIN_COLOR, 0, 2
    )
    if not tab_content_frame then warn("Failed to create tab_content_frame: " .. tab_name); return nil end
    tab_content_frame.Visible = false -- Hidden by default
    tab_content_frame.ClipsDescendants = true -- Important for content scrolling

    local ui_list_layout = Instance.new("UIListLayout")
    ui_list_layout.FillDirection = Enum.FillDirection.Vertical
    ui_list_layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    ui_list_layout.VerticalAlignment = Enum.VerticalAlignment.Top
    ui_list_layout.Padding = UDim.new(0, GUI_SETTINGS.ELEMENT_SPACING)
    ui_list_layout.Parent = tab_content_frame

    local ui_padding = Instance.new("UIPadding")
    ui_padding.PaddingLeft = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingRight = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingTop = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingBottom = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.Parent = tab_content_frame

    local function CreateSection(section_name)
        local section_header = CreateTextLabel(tab_content_frame, section_name .. "Header",
            section_name,
            UDim2.new(1, 0, 0, GUI_SETTINGS.SECTION_HEADER_HEIGHT),
            UDim2.new(0, 0, 0, 0), -- Position handled by UIListLayout
            GUI_SETTINGS.BORDER_COLOR, 0, 3, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE + 1, GUI_SETTINGS.TEXT_COLOR, Enum.TextXAlignment.Center
        )
        if not section_header then warn("Failed to create section_header: " .. section_name); return nil end

        local section_container = CreateFrame(tab_content_frame, section_name .. "SectionContainer",
            UDim2.new(1, 0, 0, 0), -- Size will be updated by UIListLayout
            UDim2.new(0, 0, 0, 0), -- Position handled by UIListLayout
            GUI_SETTINGS.MAIN_COLOR, 1, 3
        )
        if not section_container then warn("Failed to create section_container: " .. section_name); return nil end

        local section_layout = Instance.new("UIListLayout")
        section_layout.FillDirection = Enum.FillDirection.Vertical
        section_layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        section_layout.VerticalAlignment = Enum.VerticalAlignment.Top
        section_layout.Padding = UDim.new(0, GUI_SETTINGS.ELEMENT_SPACING)
        section_layout.Parent = section_container

        return {
            Container = section_container,
            CreateToggle = function(params)
                print("Creating toggle: " .. params.Name)
                local el, get_value = CreateToggle(section_container, params.Name, params.Default, params.Callback)
                return get_value
            end,
            CreateSlider = function(params)
                print("Creating slider: " .. params.Name)
                local el, get_value = CreateSlider(section_container, params.Name, params.Range, params.Increment, params.Suffix, params.CurrentValue, params.Callback)
                return get_value
            end,
            CreateButton = function(params)
                print("Creating button: " .. params.Name)
                local el = CreateTextButton(section_container, params.Name, params.Name, UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR, 3, params.Callback)
            end,
            CreateTextBox = function(params)
                print("Creating textbox: " .. params.Name)
                local el, get_value = CreateTextBox(section_container, params.Name, params.Placeholder, params.Text, params.Callback)
                return get_value
            end,
            GetValue = function(element_name)
                return UI_STATE[element_name]
            end
        }
    end

    table.insert(tabs, {
        Name = tab_name,
        Button = tab_button,
        Content = tab_content_frame,
        CreateSection = CreateSection,
    })

    tab_button.MouseButton1Click:Connect(function()
        for _, tab_info in pairs(tabs) do
            tab_info.Content.Visible = false
            tab_info.Button.BackgroundColor3 = GUI_SETTINGS.BORDER_COLOR
            tab_info.Button.TextColor3 = GUI_SETTINGS.TEXT_COLOR
        end
        tab_content_frame.Visible = true
        tab_button.BackgroundColor3 = GUI_SETTINGS.ACCENT_COLOR
        tab_button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White for active tab
        active_tab_name = tab_name
        print("Tab changed to: " .. tab_name)
    end)

    return tabs[tab_index]
end

-- Initialize the first tab as active
local function SetActiveTab(tab_name)
    local success, err = pcall(function()
        for _, tab_info in pairs(tabs) do
            if tab_info.Name == tab_name then
                tab_info.Button.MouseButton1Click:Fire() -- Simulate a click
                return
            end
        end
        warn("Could not find tab to set active: " .. tab_name)
    end)
    if not success then warn("SetActiveTab failed: " .. err) end
end

-- ============================================================================
-- 5. Notification System (Basic)
-- ============================================================================
print("Creating Notification System...")
local notifications_frame = CreateFrame(main_screen_gui, "Notifications",
    UDim2.new(0, 250, 0, 0), UDim2.new(1, -260, 0, 10),
    GUI_SETTINGS.MAIN_COLOR, 0.2, 5
)
if not notifications_frame then warn("Failed to create notifications_frame."); return end
notifications_frame.LayoutOrder = 1 -- Ensure it's rendered first in its parent
notifications_frame.BackgroundTransparency = 1 -- Start fully transparent
notifications_frame.BorderSizePixel = 0

local notification_layout = Instance.new("UIListLayout")
notification_layout.FillDirection = Enum.FillDirection.Vertical
notification_layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
notification_layout.VerticalAlignment = Enum.VerticalAlignment.Top
notification_layout.Padding = UDim.new(0, 5)
notification_layout.Parent = notifications_frame
print("Notification System created.")

local function Notify(params)
    print("Notification received: " .. (params.Title or "") .. " - " .. (params.Content or ""))
    local title = params.Title or "Notification"
    local content = params.Content or ""
    local duration = params.Duration or 3
    local image_id = params.Image or nil -- Optional image icon

    local notification_panel = CreateFrame(notifications_frame, "NotificationPanel",
        UDim2.new(1, 0, 0, 60), UDim2.new(0, 0, 0, 0),
        GUI_SETTINGS.MAIN_COLOR, 0, 6
    )
    if not notification_panel then return end
    notification_panel.BorderSizePixel = 1
    notification_panel.BorderColor3 = GUI_SETTINGS.BORDER_COLOR
    local ui_corner_noti = Instance.new("UICorner")
    ui_corner_noti.CornerRadius = UDim.new(0, 6)
    ui_corner_noti.Parent = notification_panel

    local title_label = CreateTextLabel(notification_panel, "Title", title,
        UDim2.new(1, 0, 0.4, 0), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.PADDING),
        nil, 1, 7, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE + 2, GUI_SETTINGS.TEXT_COLOR, Enum.TextXAlignment.Left
    )
    local content_label = CreateTextLabel(notification_panel, "Content", content,
        UDim2.new(1, 0, 0.6, 0), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.PADDING + 20),
        nil, 1, 7, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE, GUI_SETTINGS.TEXT_COLOR:Lerp(Color3.fromRGB(255,255,255), 0.5), Enum.TextXAlignment.Left
    )

    local image_label = nil
    if image_id then
        local success, err = pcall(function()
            image_label = Instance.new("ImageLabel")
            image_label.Name = "Icon"
            image_label.Image = image_id
            image_label.Size = UDim2.new(0, 40, 0, 40)
            image_label.Position = UDim2.new(1, -45, 0.5, -20)
            image_label.BackgroundTransparency = 1
            image_label.Parent = notification_panel
        end)
        if not success then warn("Failed to create notification ImageLabel: " .. err) end
    end

    -- Fade in animation
    notification_panel.BackgroundTransparency = 1
    if title_label then title_label.TextTransparency = 1 end
    if content_label then content_label.TextTransparency = 1 end
    if image_label then image_label.ImageTransparency = 1 end

    local tween_info_in = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween_info_out = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local function animate_fade(target_transparency, callback)
        local tween_params = { BackgroundTransparency = target_transparency }
        TweenService:Create(notification_panel, tween_info_in, tween_params):Play()
        if title_label then TweenService:Create(title_label, tween_info_in, { TextTransparency = target_transparency }):Play() end
        if content_label then TweenService:Create(content_label, tween_info_in, { TextTransparency = target_transparency }):Play() end
        if image_label then TweenService:Create(image_label, tween_info_in, { ImageTransparency = target_transparency }):Play() end
        if callback then
            task.delay(tween_info_in.Time, callback)
        end
    end

    animate_fade(0, function()
        task.delay(duration, function()
            animate_fade(1, function()
                if notification_panel then notification_panel:Destroy() end
            end)
        end)
    end)
end

-- ============================================================================
-- 6. Define Tabs and Their Sections
-- ============================================================================
print("Defining Tabs and Sections...")
local PlayerTab = CreateTab("Player")
local VisualsTab = CreateTab("Visuals")
local UtilityTab = CreateTab("Utility")
local FunTab = CreateTab("Fun & Misc")
local SettingsTab = CreateTab("Settings")
print("Tabs defined.")

-- ============================================================================
-- 7. Player Tab Features
-- ============================================================================
print("Adding Player Tab features...")
-- Section: Movement
local MovementSection = PlayerTab.CreateSection("Movement")

-- Feature: WalkSpeed Slider
local walkspeed_connection = nil
local get_walkspeed_value = MovementSection.CreateSlider({
    Name = "WalkSpeed",
    Range = {16, 500},
    Increment = 1,
    Suffix = " studs/s",
    CurrentValue = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.WalkSpeed or 16,
    Callback = function(value)
        if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.WalkSpeed = value
        end
        if walkspeed_connection then walkspeed_connection:Disconnect() end
        walkspeed_connection = LocalPlayer.CharacterAdded:Connect(function(char)
            local humanoid = char:WaitForChild("Humanoid", 5)
            if humanoid then humanoid.WalkSpeed = value end
        end)
    end,
})

-- Feature: JumpPower Slider
local jumppower_connection = nil
local get_jumppower_value = MovementSection.CreateSlider({
    Name = "JumpPower",
    Range = {50, 500},
    Increment = 5,
    Suffix = " power",
    CurrentValue = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.JumpPower or 50,
    Callback = function(value)
        if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.JumpPower = value
        end
        if jumppower_connection then jumppower_connection:Disconnect() end
        jumppower_connection = LocalPlayer.CharacterAdded:Connect(function(char)
            local humanoid = char:WaitForChild("Humanoid", 5)
            if humanoid then humanoid.JumpPower = value end
        end)
    end,
})

-- Feature: Infinite Jump Toggle
local infinite_jump_enabled = false
local infinite_jump_connection = nil
MovementSection.CreateToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(state)
        infinite_jump_enabled = state
        if infinite_jump_enabled then
            infinite_jump_connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space and not gameProcessedEvent then
                    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.Health > 0 then
                        LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end)
        else
            if infinite_jump_connection then
                infinite_jump_connection:Disconnect()
                infinite_jump_connection = nil
            end
        end
    end,
})

-- Feature: Noclip Toggle (Client-sided)
local noclip_enabled = false
local noclip_connection = nil
local original_collision_groups = {} -- Store original collision groups
MovementSection.CreateToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(state)
        noclip_enabled = state
        if LocalPlayer and LocalPlayer.Character then
            if noclip_enabled then
                original_collision_groups = {}
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        original_collision_groups[part] = part.CollisionGroup
                        -- Important: "NoCollision" group needs to exist in PhysicsService.
                        -- Exploit executors usually provide this or similar functionality.
                        -- A client script cannot create a new CollisionGroup directly.
                        part.CollisionGroup = "NoCollision" 
                    end
                end
                if not noclip_connection then
                    noclip_connection = RunService.Stepped:Connect(function()
                        if noclip_enabled and LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                            LocalPlayer.Character.Humanoid.PlatformStand = true
                        end
                    end)
                end
            else
                for part, original_group in pairs(original_collision_groups) do
                    if part and part:IsA("BasePart") then
                        part.CollisionGroup = original_group
                    end
                end
                original_collision_groups = {}
                if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid.PlatformStand = false
                end
                if noclip_connection then
                    noclip_connection:Disconnect()
                    noclip_connection = nil
                end
            end
        end
    end,
})

-- Section: Health & Godmode
local HealthSection = PlayerTab.CreateSection("Health")

-- Feature: Godmode Toggle (Client-sided visual effect)
local godmode_enabled = false
local godmode_humanoid_connection = nil
HealthSection.CreateToggle({
    Name = "Godmode (Visual)",
    Default = false,
    Callback = function(state)
        godmode_enabled = state
        if godmode_humanoid_connection then godmode_humanoid_connection:Disconnect() end
        if godmode_enabled then
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                LocalPlayer.Character.Humanoid.MaxHealth = math.huge
                LocalPlayer.Character.Humanoid.Health = LocalPlayer.Character.Humanoid.MaxHealth
            end
            godmode_humanoid_connection = LocalPlayer.CharacterAdded:Connect(function(char)
                local humanoid = char:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.MaxHealth = math.huge
                    humanoid.Health = humanoid.MaxHealth
                end
            end)
        else
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                LocalPlayer.Character.Humanoid.MaxHealth = 100
                LocalPlayer.Character.Humanoid.Health = 100
            end
        end
    end,
})

-- Feature: Heal Button
HealthSection.CreateButton({
    Name = "Heal Player",
    Callback = function()
        if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.Health = LocalPlayer.Character.Humanoid.MaxHealth
            Notify({
                Title = "Healed!",
                Content = "You have been fully healed.",
                Duration = 3,
                Image = "rbxassetid://6253457193",
            })
        else
            Notify({
                Title = "Error",
                Content = "Could not heal. Character or Humanoid not found.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
        end
    end,
})
print("Finished Player Tab features.")

-- ============================================================================
-- 8. Visuals Tab Features
-- ============================================================================
print("Adding Visuals Tab features...")
-- Section: ESP (Client-sided outlines)
local ESPSection = VisualsTab.CreateSection("ESP")

local esp_connections = {}
local esp_parts_storage = {} -- Store references to ESP parts to clean them up

local function create_esp_highlight(target_part, color)
    if not target_part or not target_part:IsA("BasePart") then return end

    local highlight = Instance.new("Highlight")
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = color
    highlight.FillColor = Color3.fromRGB(color.R, color.G, color.B)
    highlight.Adornee = target_part
    highlight.Parent = target_part
    table.insert(esp_parts_storage, highlight)
    return highlight
end

local function toggle_player_esp(state)
    for _, conn in pairs(esp_connections) do if conn and conn.Connected then conn:Disconnect() end end
    esp_connections = {}

    for _, highlight in pairs(esp_parts_storage) do
        if highlight and highlight.Parent then highlight:Destroy() end
    end
    esp_parts_storage = {}

    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local function add_char_esp(char)
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            create_esp_highlight(part, Color3.fromRGB(255, 0, 0)) -- Red for players
                        end
                    end
                end
                add_char_esp(player.Character)
                table.insert(esp_connections, player.CharacterAdded:Connect(add_char_esp))
            end
        end
        table.insert(esp_connections, Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
                table.insert(esp_connections, player.CharacterAdded:Connect(function(char)
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            create_esp_highlight(part, Color3.fromRGB(255, 0, 0))
                        end
                    end
                end))
            end
        end))
        table.insert(esp_connections, Players.PlayerRemoving:Connect(function(player)
            for i = #esp_parts_storage, 1, -1 do
                local highlight = esp_parts_storage[i]
                if highlight and highlight.Adornee and highlight.Adornee:IsDescendantOf(player.Character) then
                    highlight:Destroy()
                    table.remove(esp_parts_storage, i)
                end
            end
        end))
    end
end

ESPSection.CreateToggle({
    Name = "Player ESP",
    Default = false,
    Callback = function(state)
        toggle_player_esp(state)
    end,
})

-- Section: Environment
local EnvironmentSection = VisualsTab.CreateSection("Environment")

-- Feature: Full Bright Toggle
local full_bright_enabled = false
local original_ambient = Lighting.Ambient
local original_outdoor_ambient = Lighting.OutdoorAmbient
local original_brightness = Lighting.Brightness
local original_exposure = Lighting.ExposureCompensation
EnvironmentSection.CreateToggle({
    Name = "Full Bright",
    Default = false,
    Callback = function(state)
        full_bright_enabled = state
        if full_bright_enabled then
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 3
            Lighting.ExposureCompensation = 1
        else
            Lighting.Ambient = original_ambient
            Lighting.OutdoorAmbient = original_outdoor_ambient
            Lighting.Brightness = original_brightness
            Lighting.ExposureCompensation = original_exposure
        end
    end,
})

-- Feature: Time of Day Slider
EnvironmentSection.CreateSlider({
    Name = "Time of Day",
    Range = {0, 24},
    Increment = 0.1,
    Suffix = " hours",
    CurrentValue = Lighting:GetMinutesAfterMidnight() / 60,
    Callback = function(value)
        Lighting:SetMinutesAfterMidnight(value * 60)
    end,
})

-- Section: Tracers
local TracerSection = VisualsTab.CreateSection("Tracers")

local tracer_active = false
local tracer_lines = {}
local tracer_connection = nil

local function create_tracer(target_player)
    local line = Instance.new("Part")
    line.BrickColor = BrickColor.new("Bright yellow")
    line.Material = Enum.Material.Neon
    line.Anchored = true
    line.CanCollide = false
    line.Transparency = 0.5
    line.Size = Vector3.new(0.1, 0.1, 0.1)
    line.Parent = Workspace.CurrentCamera -- Parent to camera for consistent rendering in some cases
    line.Name = "PlayerTracer_" .. target_player.Name
    table.insert(tracer_lines, line)
    return line
end

TracerSection.CreateToggle({
    Name = "Player Tracers",
    Default = false,
    Callback = function(state)
        tracer_active = state
        if tracer_connection then tracer_connection:Disconnect() end

        for _, line in pairs(tracer_lines) do
            if line and line.Parent then line:Destroy() end
        end
        tracer_lines = {}

        if tracer_active then
            tracer_connection = RunService.RenderStepped:Connect(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local root_part = player.Character.HumanoidRootPart
                        
                        local tracer_line = nil
                        for _, line_obj in pairs(tracer_lines) do
                            if line_obj and line_obj.Name == "PlayerTracer_" .. player.Name then
                                tracer_line = line_obj
                                break
                            end
                        end
                        if not tracer_line then
                            tracer_line = create_tracer(player)
                        end
                        if not tracer_line then continue end -- Skip if creation failed

                        local start_world = Workspace.CurrentCamera.CFrame.Position
                        local end_world = root_part.Position
                        local distance = (start_world - end_world).magnitude

                        tracer_line.CFrame = CFrame.new(start_world, end_world) * CFrame.new(0, 0, -distance / 2)
                        tracer_line.Size = Vector3.new(0.1, 0.1, distance)
                        -- Parent to Workspace to ensure it's rendered as a 3D object
                        if tracer_line.Parent ~= Workspace then tracer_line.Parent = Workspace end
                    else
                        -- Remove tracer if player is invalid, left, or character isn't ready
                        for i = #tracer_lines, 1, -1 do
                            local line_obj = tracer_lines[i]
                            if line_obj and line_obj.Name == "PlayerTracer_" .. player.Name then
                                if line_obj.Parent then line_obj:Destroy() end
                                table.remove(tracer_lines, i)
                                break
                            end
                        end
                    end
                end

                -- Clean up tracers for players who left (fallback for `PlayerRemoving`)
                for i = #tracer_lines, 1, -1 do
                    local line_obj = tracer_lines[i]
                    local player_name_from_tracer = string.match(line_obj.Name, "PlayerTracer_(.+)")
                    if not Players:FindFirstChild(player_name_from_tracer) then
                        if line_obj and line_obj.Parent then line_obj:Destroy() end
                        table.remove(tracer_lines, i)
                    end
                end
            end)
        end
    end,
})
print("Finished Visuals Tab features.")

-- ============================================================================
-- 9. Utility Tab Features
-- ============================================================================
print("Adding Utility Tab features...")
-- Section: Teleports
local TeleportSection = UtilityTab.CreateSection("Teleports")

-- Feature: Teleport to Mouse
TeleportSection.CreateButton({
    Name = "Teleport to Mouse",
    Callback = function()
        local mouse = LocalPlayer:GetMouse()
        if not mouse or not mouse.Hit then
            Notify({ Title = "Error", Content = "Mouse hit position not available.", Duration = 3 })
            return
        end
        local hit_pos = mouse.Hit.Position
        if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(hit_pos + Vector3.new(0, 5, 0))
            Notify({
                Title = "Teleported!",
                Content = "Teleported to mouse position.",
                Duration = 3,
                Image = "rbxassetid://540417643",
            })
        else
            Notify({
                Title = "Error",
                Content = "Could not teleport. Character or HumanoidRootPart not found.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
        end
    end,
})

-- Feature: Teleport to Player (Textbox)
local get_player_teleport_name = TeleportSection.CreateTextBox({
    Name = "Player Name",
    Placeholder = "Enter player name...",
    Text = "",
    Callback = function(text)
        -- Value automatically stored in UI_STATE["Player Name"] by CreateTextBox
    end,
})

TeleportSection.CreateButton({
    Name = "Teleport to Player",
    Callback = function()
        local player_name = get_player_teleport_name()
        if not player_name or player_name == "" then
            Notify({
                Title = "Error",
                Content = "Please enter a player name to teleport to.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
            return
        end

        local target_player = Players:FindFirstChild(player_name)
        if target_player and target_player.Character and target_player.Character:FindFirstChild("HumanoidRootPart") then
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart then
                LocalPlayer.Character.HumanoidRootPart.CFrame = target_player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
                Notify({
                    Title = "Teleported!",
                    Content = "Teleported to " .. target_player.Name .. ".",
                    Duration = 3,
                    Image = "rbxassetid://540417643",
                })
            end
        else
            Notify({
                Title = "Error",
                Content = "Player '" .. player_name .. "' not found or character not loaded.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
        end
    end,
})

-- Section: General Utility
local GeneralUtilitySection = UtilityTab.CreateSection("General Utility")

-- Feature: Anti-AFK Toggle
local anti_afk_enabled = false
local anti_afk_connection = nil
GeneralUtilitySection.CreateToggle({
    Name = "Anti-AFK",
    Default = false,
    Callback = function(state)
        anti_afk_enabled = state
        if anti_afk_connection then anti_afk_connection:Disconnect() end
        if anti_afk_enabled then
            anti_afk_connection = RunService.Heartbeat:Connect(function()
                if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    -- Simulate a small movement to prevent AFK kick
                    LocalPlayer.Character.Humanoid:Move(Vector3.new(0.01, 0, 0))
                    task.wait(0.1)
                    LocalPlayer.Character.Humanoid:Move(Vector3.new(-0.01, 0, 0))
                end
            end)
        end
    end,
})
print("Finished Utility Tab features.")

-- ============================================================================
-- 10. Fun & Misc Tab Features
-- ============================================================================
print("Adding Fun & Misc Tab features...")
-- Section: Particles & Effects
local EffectsSection = FunTab.CreateSection("Particles & Effects")

-- Feature: Client-sided Fire Particles
local fire_particles_enabled = false
local fire_particle_attachment = nil
EffectsSection.CreateToggle({
    Name = "Spawn Fire Particles",
    Default = false,
    Callback = function(state)
        fire_particles_enabled = state
        if fire_particle_attachment and fire_particle_attachment.Parent then fire_particle_attachment:Destroy() end

        if fire_particles_enabled then
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                fire_particle_attachment = Instance.new("Attachment")
                fire_particle_attachment.Parent = LocalPlayer.Character.HumanoidRootPart

                local fire = Instance.new("ParticleEmitter")
                fire.Texture = "rbxassetid://257924844"
                fire.Acceleration = Vector3.new(0, 5, 0)
                fire.Brightness = 2
                fire.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0), Color3.fromRGB(255, 0, 0))
                fire.Drag = 0.05
                fire.Enabled = true
                fire.Lifetime = NumberRange.new(0.5, 1.5)
                fire.LightInfluence = 0.5
                fire.Rate = 100
                fire.Rotation = NumberRange.new(-180, 180)
                fire.RotSpeed = NumberRange.new(-50, 50)
                fire.Size = NumberSequence.new(0.5, 2)
                fire.Speed = NumberRange.new(1, 5)
                fire.SpreadAngle = Vector2.new(90, 90)
                fire.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(0.5, 0.5),
                    NumberSequenceKeypoint.new(1, 1)
                })
                fire.VelocityInheritance = 0.5
                fire.ZOffset = 0
                fire.Parent = fire_particle_attachment
            else
                Notify({
                    Title = "Error",
                    Content = "Character or HumanoidRootPart not found for particles.",
                    Duration = 5,
                })
            end
        end
    end,
})

-- Feature: Client-sided Smoke Particles
local smoke_particles_enabled = false
local smoke_particle_attachment = nil
EffectsSection.CreateToggle({
    Name = "Spawn Smoke Particles",
    Default = false,
    Callback = function(state)
        smoke_particles_enabled = state
        if smoke_particle_attachment and smoke_particle_attachment.Parent then smoke_particle_attachment:Destroy() end

        if smoke_particles_enabled then
            if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                smoke_particle_attachment = Instance.new("Attachment")
                smoke_particle_attachment.Parent = LocalPlayer.Character.HumanoidRootPart

                local smoke = Instance.new("ParticleEmitter")
                smoke.Texture = "rbxassetid://616335129"
                smoke.Acceleration = Vector3.new(0, 2, 0)
                smoke.Brightness = 1
                smoke.Color = ColorSequence.new(Color3.fromRGB(100, 100, 100), Color3.fromRGB(50, 50, 50))
                smoke.Drag = 0.05
                smoke.Enabled = true
                smoke.Lifetime = NumberRange.new(2, 4)
                smoke.LightInfluence = 0.5
                smoke.Rate = 50
                smoke.Rotation = NumberRange.new(-180, 180)
                smoke.RotSpeed = NumberRange.new(-20, 20)
                smoke.Size = NumberSequence.new(1, 5)
                smoke.Speed = NumberRange.new(0.5, 2)
                smoke.SpreadAngle = Vector2.new(45, 45)
                smoke.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(0.2, 0.2),
                    NumberSequenceKeypoint.new(1, 1)
                })
                smoke.VelocityInheritance = 0.2
                smoke.ZOffset = 0
                smoke.Parent = smoke_particle_attachment
            else
                Notify({
                    Title = "Error",
                    Content = "Character or HumanoidRootPart not found for particles.",
                    Duration = 5,
                })
            end
        end
    end,
})


-- Section: Chat & Audio (Client-sided)
local ChatAudioSection = FunTab.CreateSection("Chat & Audio")

-- Feature: Chat Spammer (Client-sided)
local chat_spam_enabled = false
local get_chat_spam_message = ChatAudioSection.CreateTextBox({
    Name = "Spam Message",
    Placeholder = "Enter message to spam...",
    Text = "Hello from FunHub!",
    Callback = function(text)
        -- Value automatically stored
    end,
})
local get_chat_spam_delay = ChatAudioSection.CreateSlider({
    Name = "Spam Delay",
    Range = {0.1, 10},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = 1,
    Callback = function(value)
        -- Value automatically stored
    end,
})

local chat_spam_thread = nil
ChatAudioSection.CreateToggle({
    Name = "Enable Chat Spammer",
    Default = false,
    Callback = function(state)
        chat_spam_enabled = state
        if chat_spam_thread then task.cancel(chat_spam_thread) end

        if chat_spam_enabled then
            chat_spam_thread = task.spawn(function()
                while chat_spam_enabled do
                    if LocalPlayer and LocalPlayer.Chatted then
                        -- This simulates a local chat message. It won't send to other players
                        -- unless the game has a specific remote event listener for Chatted.
                        -- Real chat exploits use RemoteEvents or game-specific chat functions.
                        -- This is purely client-sided for demonstration.
                        local success, err = pcall(LocalPlayer.Chatted.Fire, LocalPlayer.Chatted, "rbx_local_chat", get_chat_spam_message())
                        if not success then warn("Local chat simulation failed: " .. err) end
                    end
                    task.wait(get_chat_spam_delay())
                end
            end)
        else
            Notify({
                Title = "Chat Spammer",
                Content = "Chat Spammer Disabled.",
                Duration = 2,
            })
        end
    end,
})

-- Feature: Play Sound Effect (Client-sided)
ChatAudioSection.CreateButton({
    Name = "Play Fun Sound",
    Callback = function()
        local sound_id = "rbxassetid://106579069" -- Example: Default Roblox 'Woosh' sound
        local sound = Instance.new("Sound")
        if not sound then Notify({ Title = "Error", Content = "Failed to create Sound instance.", Duration = 3 }); return end
        
        sound.SoundId = sound_id
        sound.Parent = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or Workspace
        sound.Volume = 0.5
        local success, err = pcall(sound.Play, sound)
        if not success then warn("Sound playback failed: " .. err) end

        Debris:AddItem(sound, sound.TimeLength + 1)
        Notify({
            Title = "Sound Played!",
            Content = "A fun sound effect has been played.",
            Duration = 3,
        })
    end,
})
print("Finished Fun & Misc Tab features.")

-- ============================================================================
-- 11. Settings Tab
-- ============================================================================
print("Adding Settings Tab features...")
local UISettingsSection = SettingsTab.CreateSection("UI Settings")

-- Feature: Toggle UI Visibility
UISettingsSection.CreateButton({
    Name = "Toggle UI (Hide/Show)",
    Callback = function()
        if main_frame then
            main_frame.Visible = not main_frame.Visible
            is_ui_open = main_frame.Visible
            Notify({
                Title = "UI Toggled",
                Content = "UI is now " .. (is_ui_open and "visible" or "hidden") .. ".",
                Duration = 2,
            })
        else
            Notify({ Title = "Error", Content = "Main UI frame not found.", Duration = 3 })
        end
    end,
})

-- Feature: Destroy UI (Careful with this!)
UISettingsSection.CreateButton({
    Name = "Destroy UI",
    Callback = function()
        Notify({
            Title = "Destroying UI...",
            Content = "The FunHub UI will be destroyed.",
            Duration = 3,
            Image = "rbxassetid://6253457193",
        })
        task.wait(0.5)
        if main_screen_gui and main_screen_gui.Parent then
            main_screen_gui:Destroy()
            print("UI destroyed.")
        else
            warn("Attempted to destroy UI but main_screen_gui not found or already destroyed.")
        end
    end,
})
print("Finished Settings Tab features.")

-- ============================================================================
-- 12. Final Initializations & Callbacks
-- ============================================================================
print("Performing final initializations...")
-- Restore initial states if character respawns (for walkspeed, jumppower, godmode)
LocalPlayer.CharacterAdded:Connect(function(char)
    local humanoid = char:WaitForChild("Humanoid", 5)
    if not humanoid then return end -- Skip if humanoid doesn't load

    -- Re-apply walkspeed if slider was used
    local ws_val = get_walkspeed_value()
    if ws_val then
        humanoid.WalkSpeed = ws_val
    end
    -- Re-apply jumppower if slider was used
    local jp_val = get_jumppower_value()
    if jp_val then
        humanoid.JumpPower = jp_val
    end
    -- Re-apply godmode visual if enabled
    if godmode_enabled then
        humanoid.MaxHealth = math.huge
        humanoid.Health = humanoid.MaxHealth
    end
    -- Noclip reconnect (important for keeping it active after death)
    if noclip_enabled then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CollisionGroup = "NoCollision"
            end
        end
        -- Re-establish stepped connection if it was lost (noclip)
        if not noclip_connection then
            noclip_connection = RunService.Stepped:Connect(function()
                if noclip_enabled and LocalPlayer and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid.PlatformStand = true
                end
            end)
        end
    end
end)

-- Set the initial active tab
SetActiveTab("Player")

-- Initial notification that the script is loaded
Notify({
    Title = "FunHub Custom UI Loaded!",
    Content = "The custom UI script has been successfully loaded. Check console for debug prints.",
    Duration = 5,
    Image = "rbxassetid://4655452243",
})
print("FunHub Custom UI loaded successfully!")

-- ============================================================================
-- Script End
-- ============================================================================
