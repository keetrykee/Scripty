--! lz -- This line might be used by some executors to indicate LuaZ (bytecode) obfuscation, often just a comment.

--[[
    Custom GUI Fun Script - Pure Roblox Instances
    Generated by Gemini

    Disclaimer:
    This script creates a custom Graphical User Interface (GUI) directly using
    Roblox's built-in Instance objects (ScreenGui, Frame, etc.)
    It does NOT use any external UI libraries like Rayfield.

    - This script is designed for demonstration and educational purposes.
    - It is NOT guaranteed to be perfectly bug-free or compatible with all
      Roblox game environments or exploit executors without testing.
    - The visual styling aims for a clean look but might not exactly match
      Rayfield's specific aesthetic without advanced rendering techniques.
    - All features are client-sided unless explicitly stated otherwise.
    - Use responsibly and understand the terms of service of the games you play.
    - No aimbot features are included as per your request.

    Line Count Goal: ~900+ lines (This will be significantly longer due to manual GUI construction)
]]

-- ============================================================================
-- 1. Initial Setup: Roblox Services & Global Variables
-- ============================================================================

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local CoreGui = game:GetService("CoreGui")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService") -- For generating unique IDs for elements

-- Global script variables and states
local script_name = "FunHub_CustomUI"
local script_version = "1.0.0"
local is_ui_open = true -- Initial state of the UI

-- ============================================================================
-- 2. Custom UI Framework: Core Functions for Creating Elements
-- ============================================================================

local GUI_SETTINGS = {
    MAIN_COLOR = Color3.fromRGB(30, 30, 30),
    ACCENT_COLOR = Color3.fromRGB(80, 150, 255), -- Rayfield-like blue
    TEXT_COLOR = Color3.fromRGB(200, 200, 200),
    BORDER_COLOR = Color3.fromRGB(45, 45, 45),
    TEXT_FONT = Enum.Font.SourceSans,
    TEXT_SIZE = 14,
    HEADER_HEIGHT = 28,
    TAB_HEIGHT = 30,
    SECTION_HEADER_HEIGHT = 24,
    ELEMENT_HEIGHT = 20,
    PADDING = 5,
    ELEMENT_SPACING = 3,
    WINDOW_WIDTH = 400,
    WINDOW_HEIGHT = 300,
}

local UI_STATE = {} -- Store states of toggles, sliders, etc.

-- Function to create a basic frame
local function CreateFrame(parent, name, size, position, color, transparency, ZIndex)
    local frame = Instance.new("Frame")
    frame.Name = name or HttpService:GenerateGUID(false)
    frame.Size = size or UDim2.new(1, 0, 1, 0)
    frame.Position = position or UDim2.new(0, 0, 0, 0)
    frame.BackgroundColor3 = color or GUI_SETTINGS.MAIN_COLOR
    frame.BackgroundTransparency = transparency or 0
    frame.BorderSizePixel = 0
    frame.ZIndex = ZIndex or 1
    frame.Parent = parent
    return frame
end

-- Function to create a basic text label
local function CreateTextLabel(parent, name, text, size, position, color, transparency, ZIndex, font, textSize, textColor)
    local label = Instance.new("TextLabel")
    label.Name = name or HttpService:GenerateGUID(false)
    label.Text = text or ""
    label.Size = size or UDim2.new(1, 0, 1, 0)
    label.Position = position or UDim2.new(0, 0, 0, 0)
    label.BackgroundColor3 = color or GUI_SETTINGS.MAIN_COLOR
    label.BackgroundTransparency = transparency or 1
    label.TextColor3 = textColor or GUI_SETTINGS.TEXT_COLOR
    label.Font = font or GUI_SETTINGS.TEXT_FONT
    label.TextSize = textSize or GUI_SETTINGS.TEXT_SIZE
    label.TextScaled = false
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextWrapped = true
    label.ZIndex = ZIndex or 1
    label.Parent = parent
    return label
end

-- Function to create a basic text button
local function CreateTextButton(parent, name, text, size, position, color, textColor, ZIndex, callback)
    local button = Instance.new("TextButton")
    button.Name = name or HttpService:GenerateGUID(false)
    button.Text = text or ""
    button.Size = size or UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT)
    button.Position = position or UDim2.new(0, 0, 0, 0)
    button.BackgroundColor3 = color or GUI_SETTINGS.BORDER_COLOR
    button.BackgroundTransparency = 0
    button.TextColor3 = textColor or GUI_SETTINGS.TEXT_COLOR
    button.Font = GUI_SETTINGS.TEXT_FONT
    button.TextSize = GUI_SETTINGS.TEXT_SIZE
    button.TextScaled = false
    button.BorderSizePixel = 0
    button.ZIndex = ZIndex or 1
    button.Parent = parent

    local function on_button_hover(enter)
        if enter then
            button.BackgroundColor3 = GUI_SETTINGS.ACCENT_COLOR:Lerp(button.BackgroundColor3, 0.7)
        else
            button.BackgroundColor3 = color or GUI_SETTINGS.BORDER_COLOR
        end
    end
    button.MouseEnter:Connect(function() on_button_hover(true) end)
    button.MouseLeave:Connect(function() on_button_hover(false) end)

    if callback then
        button.MouseButton1Click:Connect(callback)
    end
    return button
end

-- Function to create a toggle switch
local function CreateToggle(parent, name, default_state, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)

    local toggle_state = default_state
    UI_STATE[name] = toggle_state

    local name_label = CreateTextLabel(container, "NameLabel", name, UDim2.new(1, -GUI_SETTINGS.ELEMENT_HEIGHT - GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), nil, 1)
    name_label.TextXAlignment = Enum.TextXAlignment.Left

    local toggle_button = CreateTextButton(container, "ToggleButton", "", UDim2.new(0, GUI_SETTINGS.ELEMENT_HEIGHT, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(1, -GUI_SETTINGS.ELEMENT_HEIGHT - GUI_SETTINGS.PADDING, 0, 0), GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR)
    toggle_button.Text = toggle_state and "ON" or "OFF"
    toggle_button.TextColor3 = toggle_state and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)

    local function update_toggle_visual()
        toggle_button.Text = toggle_state and "ON" or "OFF"
        toggle_button.TextColor3 = toggle_state and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
        toggle_button.BackgroundColor3 = toggle_state and GUI_SETTINGS.ACCENT_COLOR or GUI_SETTINGS.BORDER_COLOR
    end

    toggle_button.MouseButton1Click:Connect(function()
        toggle_state = not toggle_state
        UI_STATE[name] = toggle_state
        update_toggle_visual()
        if callback then
            callback(toggle_state)
        end
    end)

    update_toggle_visual() -- Initial visual update

    return container, function() return UI_STATE[name] end
end

-- Function to create a slider
local function CreateSlider(parent, name, range, increment, suffix, current_value, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT * 2), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)
    
    local min_val, max_val = range[1], range[2]
    local value = math.clamp(current_value, min_val, max_val)
    UI_STATE[name] = value

    local name_label = CreateTextLabel(container, "NameLabel", name, UDim2.new(1, -70, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), nil, 1)
    name_label.TextXAlignment = Enum.TextXAlignment.Left

    local value_label = CreateTextLabel(container, "ValueLabel", tostring(math.floor(value * 10) / 10) .. suffix, UDim2.new(0, 70, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(1, -70 - GUI_SETTINGS.PADDING, 0, 0), nil, 1)
    value_label.TextXAlignment = Enum.TextXAlignment.Right

    local slider_frame = CreateFrame(container, "SliderFrame", UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 0, GUI_SETTINGS.ELEMENT_HEIGHT / 2), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.ELEMENT_HEIGHT), GUI_SETTINGS.BORDER_COLOR)
    local slider_fill = CreateFrame(slider_frame, "SliderFill", UDim2.new((value - min_val) / (max_val - min_val), 0, 1, 0), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.ACCENT_COLOR)

    local dragging = false
    local function update_slider(input)
        if not dragging then return end
        local mouse_x = input.Position.X
        local frame_x = slider_frame.AbsolutePosition.X
        local frame_width = slider_frame.AbsoluteSize.X

        local normalized_pos = math.clamp((mouse_x - frame_x) / frame_width, 0, 1)
        local raw_value = min_val + normalized_pos * (max_val - min_val)
        value = math.floor(raw_value / increment + 0.5) * increment -- Round to nearest increment
        value = math.clamp(value, min_val, max_val)

        UI_STATE[name] = value
        slider_fill.Size = UDim2.new((value - min_val) / (max_val - min_val), 0, 1, 0)
        value_label.Text = tostring(math.floor(value * 10) / 10) .. suffix

        if callback then
            callback(value)
        end
    end

    slider_frame.MouseButton1Down:Connect(function()
        dragging = true
        UserInputService.InputChanged:Connect(update_slider)
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    if callback then
        callback(value) -- Initial callback
    end

    return container, function() return UI_STATE[name] end
end

-- Function to create a TextBox
local function CreateTextBox(parent, name, placeholder, default_text, callback)
    local container = CreateFrame(parent, name .. "Container", UDim2.new(1, 0, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, 0, 0, 0), GUI_SETTINGS.MAIN_COLOR, 1)

    local textbox = Instance.new("TextBox")
    textbox.Name = name .. "Input"
    textbox.PlaceholderText = placeholder or ""
    textbox.Text = default_text or ""
    textbox.Size = UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 1, 0)
    textbox.Position = UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0)
    textbox.BackgroundColor3 = GUI_SETTINGS.BORDER_COLOR
    textbox.BackgroundTransparency = 0
    textbox.TextColor3 = GUI_SETTINGS.TEXT_COLOR
    textbox.Font = GUI_SETTINGS.TEXT_FONT
    textbox.TextSize = GUI_SETTINGS.TEXT_SIZE
    textbox.TextScaled = false
    textbox.ClearTextOnFocus = false
    textbox.BorderSizePixel = 0
    textbox.ZIndex = 1
    textbox.Parent = container

    UI_STATE[name] = textbox.Text

    textbox.FocusLost:Connect(function(enterPressed)
        UI_STATE[name] = textbox.Text
        if callback then
            callback(textbox.Text)
        end
    end)

    return container, function() return UI_STATE[name] end
end


-- ============================================================================
-- 3. Main Window Construction
-- ============================================================================

local main_screen_gui = Instance.new("ScreenGui")
main_screen_gui.Name = script_name .. "_ScreenGui"
main_screen_gui.DisplayOrder = 999 -- Ensure it's on top
main_screen_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
main_screen_gui.Parent = CoreGui

local main_frame = CreateFrame(main_screen_gui, "MainWindow",
    UDim2.new(0, GUI_SETTINGS.WINDOW_WIDTH, 0, GUI_SETTINGS.WINDOW_HEIGHT),
    UDim2.new(0.5, -GUI_SETTINGS.WINDOW_WIDTH / 2, 0.5, -GUI_SETTINGS.WINDOW_HEIGHT / 2),
    GUI_SETTINGS.MAIN_COLOR, 0, 2
)
main_frame.ClipsDescendants = true -- Important for preventing elements from overflowing

-- Rounded corners for the main window (optional, but good for aesthetics)
local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 8)
uicorner.Parent = main_frame

-- Header for dragging
local header_frame = CreateFrame(main_frame, "Header",
    UDim2.new(1, 0, 0, GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, 0, 0, 0),
    GUI_SETTINGS.BORDER_COLOR, 0, 3
)
header_frame.BorderSizePixel = 0

local header_label = CreateTextLabel(header_frame, "TitleLabel",
    script_name .. " v" .. script_version,
    UDim2.new(1, -(GUI_SETTINGS.HEADER_HEIGHT * 2), 1, 0),
    UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0),
    nil, 1, 4, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE + 2, GUI_SETTINGS.TEXT_COLOR
)
header_label.TextXAlignment = Enum.TextXAlignment.Left

-- Minimize/Close Button (example)
local minimize_button = CreateTextButton(header_frame, "MinimizeButton", "-",
    UDim2.new(0, GUI_SETTINGS.HEADER_HEIGHT, 1, 0),
    UDim2.new(1, -GUI_SETTINGS.HEADER_HEIGHT, 0, 0),
    GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR, 4
)
minimize_button.TextSize = 24
minimize_button.TextScaled = false
minimize_button.MouseButton1Click:Connect(function()
    main_frame.Visible = not main_frame.Visible
    is_ui_open = main_frame.Visible
end)

-- Window dragging logic
local dragging_window = false
local drag_start_pos = Vector2.new(0, 0)
local frame_start_pos = UDim2.new(0, 0, 0, 0)

header_frame.MouseButton1Down:Connect(function(x, y)
    dragging_window = true
    drag_start_pos = UserInputService:GetMouseLocation()
    frame_start_pos = main_frame.Position
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging_window then
            local current_mouse_pos = UserInputService:GetMouseLocation()
            local delta = current_mouse_pos - drag_start_pos
            main_frame.Position = UDim2.new(0, frame_start_pos.X.Offset + delta.X, 0, frame_start_pos.Y.Offset + delta.Y)
        end
    end)
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging_window = false
    end
end)

-- ============================================================================
-- 4. Tab System
-- ============================================================================

local TAB_BUTTONS_WIDTH = 100 -- Width of each tab button
local tab_buttons_frame = CreateFrame(main_frame, "TabButtonsFrame",
    UDim2.new(0, TAB_BUTTONS_WIDTH, 1, -GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, 0, 0, GUI_SETTINGS.HEADER_HEIGHT),
    GUI_SETTINGS.BORDER_COLOR, 0, 2
)

local content_frame = CreateFrame(main_frame, "ContentFrame",
    UDim2.new(1, -TAB_BUTTONS_WIDTH, 1, -GUI_SETTINGS.HEADER_HEIGHT),
    UDim2.new(0, TAB_BUTTONS_WIDTH, 0, GUI_SETTINGS.HEADER_HEIGHT),
    GUI_SETTINGS.MAIN_COLOR, 0, 2
)
content_frame.ClipsDescendants = true -- Important for preventing elements from overflowing

local active_tab_name = nil
local tabs = {} -- Store { Name = {button, content_frame} }

local function CreateTab(tab_name)
    local tab_index = #tabs + 1
    local tab_button = CreateTextButton(tab_buttons_frame, tab_name .. "TabButton",
        tab_name,
        UDim2.new(1, 0, 0, GUI_SETTINGS.TAB_HEIGHT),
        UDim2.new(0, 0, 0, (tab_index - 1) * GUI_SETTINGS.TAB_HEIGHT),
        GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR, 3
    )
    tab_button.TextScaled = false
    tab_button.TextXAlignment = Enum.TextXAlignment.Center

    local tab_content_frame = CreateFrame(content_frame, tab_name .. "Content",
        UDim2.new(1, 0, 1, 0), UDim2.new(0, 0, 0, 0),
        GUI_SETTINGS.MAIN_COLOR, 0, 2
    )
    tab_content_frame.Visible = false -- Hidden by default
    tab_content_frame.ClipsDescendants = true -- Important for content scrolling

    local ui_list_layout = Instance.new("UIListLayout")
    ui_list_layout.FillDirection = Enum.FillDirection.Vertical
    ui_list_layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    ui_list_layout.VerticalAlignment = Enum.VerticalAlignment.Top
    ui_list_layout.Padding = UDim.new(0, GUI_SETTINGS.ELEMENT_SPACING)
    ui_list_layout.Parent = tab_content_frame

    local ui_padding = Instance.new("UIPadding")
    ui_padding.PaddingLeft = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingRight = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingTop = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.PaddingBottom = UDim.new(0, GUI_SETTINGS.PADDING)
    ui_padding.Parent = tab_content_frame

    local current_y_offset = GUI_SETTINGS.PADDING

    local function CreateSection(section_name)
        local section_header = CreateTextLabel(tab_content_frame, section_name .. "Header",
            section_name,
            UDim2.new(1, 0, 0, GUI_SETTINGS.SECTION_HEADER_HEIGHT),
            UDim2.new(0, 0, 0, current_y_offset),
            GUI_SETTINGS.BORDER_COLOR, 0, 3
        )
        section_header.TextXAlignment = Enum.TextXAlignment.Center
        section_header.TextSize = GUI_SETTINGS.TEXT_SIZE + 1
        current_y_offset = current_y_offset + GUI_SETTINGS.SECTION_HEADER_HEIGHT + GUI_SETTINGS.ELEMENT_SPACING

        local section_container = CreateFrame(tab_content_frame, section_name .. "SectionContainer",
            UDim2.new(1, 0, 0, 0), -- Size will be updated by UIListLayout
            UDim2.new(0, 0, 0, current_y_offset),
            GUI_SETTINGS.MAIN_COLOR, 1, 3
        )
        section_container.Size = UDim2.new(1, 0, 0, 0) -- Placeholder
        current_y_offset = current_y_offset + GUI_SETTINGS.ELEMENT_SPACING -- For elements below

        local section_children_count = 0

        local function AddElement(element_container)
            element_container.Parent = section_container
            section_children_count = section_children_count + 1
            -- UIListLayout handles positioning now, so manual Y offset isn't strictly needed for children
            -- But we need to track section height to adjust scrollframe if necessary.
        end

        return {
            Container = section_container,
            CreateToggle = function(params)
                local el, get_value = CreateToggle(section_container, params.Name, params.Default, params.Callback)
                AddElement(el)
                return get_value
            end,
            CreateSlider = function(params)
                local el, get_value = CreateSlider(section_container, params.Name, params.Range, params.Increment, params.Suffix, params.CurrentValue, params.Callback)
                AddElement(el)
                return get_value
            end,
            CreateButton = function(params)
                local el = CreateTextButton(section_container, params.Name, params.Name, UDim2.new(1, -GUI_SETTINGS.PADDING * 2, 0, GUI_SETTINGS.ELEMENT_HEIGHT), UDim2.new(0, GUI_SETTINGS.PADDING, 0, 0), GUI_SETTINGS.BORDER_COLOR, GUI_SETTINGS.TEXT_COLOR, 3, params.Callback)
                AddElement(el)
            end,
            CreateTextBox = function(params)
                local el, get_value = CreateTextBox(section_container, params.Name, params.Placeholder, params.Text, params.Callback)
                AddElement(el)
                return get_value
            end,
            -- Method to get a stored UI state value (e.g., from a slider)
            GetValue = function(element_name)
                return UI_STATE[element_name]
            end
        }
    end

    table.insert(tabs, {
        Name = tab_name,
        Button = tab_button,
        Content = tab_content_frame,
        CreateSection = CreateSection,
    })

    tab_button.MouseButton1Click:Connect(function()
        for _, tab_info in pairs(tabs) do
            tab_info.Content.Visible = false
            tab_info.Button.BackgroundColor3 = GUI_SETTINGS.BORDER_COLOR
            tab_info.Button.TextColor3 = GUI_SETTINGS.TEXT_COLOR
        end
        tab_content_frame.Visible = true
        tab_button.BackgroundColor3 = GUI_SETTINGS.ACCENT_COLOR
        tab_button.TextColor3 = Color3.fromRGB(255, 255, 255) -- White for active tab
        active_tab_name = tab_name
    end)

    return tabs[tab_index]
end

-- Initialize the first tab as active
local function SetActiveTab(tab_name)
    for _, tab_info in pairs(tabs) do
        if tab_info.Name == tab_name then
            tab_info.Button.MouseButton1Click:Fire() -- Simulate a click
            return
        end
    end
end

-- ============================================================================
-- 5. Notification System (Basic)
-- ============================================================================
local notifications_frame = CreateFrame(main_screen_gui, "Notifications",
    UDim2.new(0, 250, 0, 0), UDim2.new(1, -260, 0, 10),
    GUI_SETTINGS.MAIN_COLOR, 0.2, 5
)
notifications_frame.LayoutOrder = 1 -- Ensure it's rendered first in its parent
notifications_frame.BackgroundTransparency = 1 -- Start fully transparent
notifications_frame.BorderSizePixel = 0

local notification_layout = Instance.new("UIListLayout")
notification_layout.FillDirection = Enum.FillDirection.Vertical
notification_layout.HorizontalAlignment = Enum.HorizontalAlignment.Right
notification_layout.VerticalAlignment = Enum.VerticalAlignment.Top
notification_layout.Padding = UDim.new(0, 5)
notification_layout.Parent = notifications_frame

local function Notify(params)
    local title = params.Title or "Notification"
    local content = params.Content or ""
    local duration = params.Duration or 3
    local image_id = params.Image or nil -- Optional image icon

    local notification_panel = CreateFrame(notifications_frame, "NotificationPanel",
        UDim2.new(1, 0, 0, 60), UDim2.new(0, 0, 0, 0),
        GUI_SETTINGS.MAIN_COLOR, 0, 6
    )
    notification_panel.BorderSizePixel = 1
    notification_panel.BorderColor3 = GUI_SETTINGS.BORDER_COLOR
    local ui_corner = Instance.new("UICorner")
    ui_corner.CornerRadius = UDim.new(0, 6)
    ui_corner.Parent = notification_panel

    local title_label = CreateTextLabel(notification_panel, "Title", title,
        UDim2.new(1, 0, 0.4, 0), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.PADDING),
        nil, 1, 7, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE + 2, GUI_SETTINGS.TEXT_COLOR
    )
    title_label.TextXAlignment = Enum.TextXAlignment.Left

    local content_label = CreateTextLabel(notification_panel, "Content", content,
        UDim2.new(1, 0, 0.6, 0), UDim2.new(0, GUI_SETTINGS.PADDING, 0, GUI_SETTINGS.PADDING + 20),
        nil, 1, 7, GUI_SETTINGS.TEXT_FONT, GUI_SETTINGS.TEXT_SIZE, GUI_SETTINGS.TEXT_COLOR:Lerp(Color3.fromRGB(255,255,255), 0.5)
    )
    content_label.TextXAlignment = Enum.TextXAlignment.Left
    content_label.TextWrapped = true

    if image_id then
        local image_label = Instance.new("ImageLabel")
        image_label.Name = "Icon"
        image_label.Image = image_id
        image_label.Size = UDim2.new(0, 40, 0, 40)
        image_label.Position = UDim2.new(1, -45, 0.5, -20)
        image_label.BackgroundTransparency = 1
        image_label.Parent = notification_panel
    end

    -- Fade in animation
    notification_panel.BackgroundTransparency = 1
    title_label.TextTransparency = 1
    content_label.TextTransparency = 1
    if image_id then notification_panel.Icon.ImageTransparency = 1 end

    local tween_info_in = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween_info_out = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

    local function animate_fade(target_transparency, callback)
        TweenService:Create(notification_panel, tween_info_in, { BackgroundTransparency = target_transparency }):Play()
        TweenService:Create(title_label, tween_info_in, { TextTransparency = target_transparency }):Play()
        TweenService:Create(content_label, tween_info_in, { TextTransparency = target_transparency }):Play()
        if image_id and notification_panel.Icon then
            TweenService:Create(notification_panel.Icon, tween_info_in, { ImageTransparency = target_transparency }):Play()
        end
        if callback then
            task.delay(tween_info_in.Time, callback)
        end
    end

    animate_fade(0, function()
        task.delay(duration, function()
            animate_fade(1, function()
                notification_panel:Destroy()
            end)
        end)
    end)
end

-- Override Rayfield's Notify function with our custom one
_G.Rayfield_Notify = Notify -- Store a reference just in case
-- We will call our custom Notify function directly throughout the script.

-- ============================================================================
-- 6. Define Tabs and Their Sections
-- ============================================================================

local PlayerTab = CreateTab("Player")
local VisualsTab = CreateTab("Visuals")
local UtilityTab = CreateTab("Utility")
local FunTab = CreateTab("Fun & Misc")
local SettingsTab = CreateTab("Settings")

-- ============================================================================
-- 7. Player Tab Features
-- ============================================================================

-- Section: Movement
local MovementSection = PlayerTab.CreateSection("Movement")

-- Feature: WalkSpeed Slider
local walkspeed_connection = nil
local get_walkspeed_value = MovementSection.CreateSlider({
    Name = "WalkSpeed",
    Range = {16, 500},
    Increment = 1,
    Suffix = " studs/s",
    CurrentValue = LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.WalkSpeed or 16,
    Callback = function(value)
        if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.WalkSpeed = value
        end
        if walkspeed_connection then walkspeed_connection:Disconnect() end
        walkspeed_connection = LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid").WalkSpeed = value
        end)
    end,
})

-- Feature: JumpPower Slider
local jumppower_connection = nil
local get_jumppower_value = MovementSection.CreateSlider({
    Name = "JumpPower",
    Range = {50, 500},
    Increment = 5,
    Suffix = " power",
    CurrentValue = LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.JumpPower or 50,
    Callback = function(value)
        if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.JumpPower = value
        end
        if jumppower_connection then jumppower_connection:Disconnect() end
        jumppower_connection = LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid").JumpPower = value
        end)
    end,
})

-- Feature: Infinite Jump Toggle
local infinite_jump_enabled = false
local infinite_jump_connection = nil
MovementSection.CreateToggle({
    Name = "Infinite Jump",
    Default = false,
    Callback = function(state)
        infinite_jump_enabled = state
        if infinite_jump_enabled then
            infinite_jump_connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space and not gameProcessedEvent then
                    if LocalPlayer.Character and LocalPlayer.Character.Humanoid and LocalPlayer.Character.Humanoid.Health > 0 then
                        LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end)
        else
            if infinite_jump_connection then
                infinite_jump_connection:Disconnect()
                infinite_jump_connection = nil
            end
        end
    end,
})

-- Feature: Noclip Toggle (Client-sided)
local noclip_enabled = false
local noclip_connection = nil
local original_collision_groups = {} -- Store original collision groups
MovementSection.CreateToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(state)
        noclip_enabled = state
        if LocalPlayer.Character then
            if noclip_enabled then
                original_collision_groups = {}
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        original_collision_groups[part] = part.CollisionGroup
                        -- Note: "NoCollision" group needs to exist in PhysicsService.
                        -- Exploit executors often provide this or similar functionality.
                        -- You cannot create a new CollisionGroup from a client script.
                        part.CollisionGroup = "NoCollision" 
                    end
                end
                if not noclip_connection then
                    noclip_connection = RunService.Stepped:Connect(function()
                        if noclip_enabled and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                            LocalPlayer.Character.Humanoid.PlatformStand = true
                        end
                    end)
                end
            else
                for part, original_group in pairs(original_collision_groups) do
                    if part and part:IsA("BasePart") then
                        part.CollisionGroup = original_group
                    end
                end
                original_collision_groups = {}
                if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid.PlatformStand = false
                end
                if noclip_connection then
                    noclip_connection:Disconnect()
                    noclip_connection = nil
                end
            end
        end
    end,
})

-- Section: Health & Godmode
local HealthSection = PlayerTab.CreateSection("Health")

-- Feature: Godmode Toggle (Client-sided visual effect)
local godmode_enabled = false
local godmode_humanoid_connection = nil
HealthSection.CreateToggle({
    Name = "Godmode (Visual)",
    Default = false,
    Callback = function(state)
        godmode_enabled = state
        if godmode_humanoid_connection then godmode_humanoid_connection:Disconnect() end
        if godmode_enabled then
            if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                LocalPlayer.Character.Humanoid.MaxHealth = math.huge
                LocalPlayer.Character.Humanoid.Health = LocalPlayer.Character.Humanoid.MaxHealth
            end
            godmode_humanoid_connection = LocalPlayer.CharacterAdded:Connect(function(char)
                char:WaitForChild("Humanoid").MaxHealth = math.huge
                char:WaitForChild("Humanoid").Health = char:WaitForChild("Humanoid").MaxHealth
            end)
        else
            if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                LocalPlayer.Character.Humanoid.MaxHealth = 100
                LocalPlayer.Character.Humanoid.Health = 100
            end
        end
    end,
})

-- Feature: Heal Button
HealthSection.CreateButton({
    Name = "Heal Player",
    Callback = function()
        if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid.Health = LocalPlayer.Character.Humanoid.MaxHealth
            Notify({
                Title = "Healed!",
                Content = "You have been fully healed.",
                Duration = 3,
                Image = "rbxassetid://6253457193",
            })
        else
            Notify({
                Title = "Error",
                Content = "Could not heal. Character or Humanoid not found.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
        end
    end,
})

-- ============================================================================
-- 8. Visuals Tab Features
-- ============================================================================

-- Section: ESP (Client-sided outlines)
local ESPSection = VisualsTab.CreateSection("ESP")

local esp_connections = {}
local esp_parts_storage = {} -- Store references to ESP parts to clean them up

local function create_esp_highlight(target_part, color)
    if not target_part or not target_part:IsA("BasePart") then return end

    local highlight = Instance.new("Highlight")
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = color
    highlight.FillColor = Color3.fromRGB(color.R, color.G, color.B)
    highlight.Adornee = target_part
    highlight.Parent = target_part
    table.insert(esp_parts_storage, highlight)
    return highlight
end

local function toggle_player_esp(state)
    for _, conn in pairs(esp_connections) do conn:Disconnect() end
    esp_connections = {}

    for _, highlight in pairs(esp_parts_storage) do
        highlight:Destroy()
    end
    esp_parts_storage = {}

    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local function add_char_esp(char)
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            create_esp_highlight(part, Color3.fromRGB(255, 0, 0)) -- Red for players
                        end
                    end
                end
                add_char_esp(player.Character)
                table.insert(esp_connections, player.CharacterAdded:Connect(add_char_esp))
            end
        end
        table.insert(esp_connections, Players.PlayerAdded:Connect(function(player)
            if player ~= LocalPlayer then
                table.insert(esp_connections, player.CharacterAdded:Connect(function(char)
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            create_esp_highlight(part, Color3.fromRGB(255, 0, 0))
                        end
                    end
                end))
            end
        end))
        table.insert(esp_connections, Players.PlayerRemoving:Connect(function(player)
            for i = #esp_parts_storage, 1, -1 do
                local highlight = esp_parts_storage[i]
                if highlight.Adornee and highlight.Adornee:IsDescendantOf(player.Character) then
                    highlight:Destroy()
                    table.remove(esp_parts_storage, i)
                end
            end
        end))
    end
end

ESPSection.CreateToggle({
    Name = "Player ESP",
    Default = false,
    Callback = function(state)
        toggle_player_esp(state)
    end,
})

-- Section: Environment
local EnvironmentSection = VisualsTab.CreateSection("Environment")

-- Feature: Full Bright Toggle
local full_bright_enabled = false
local original_ambient = Lighting.Ambient
local original_outdoor_ambient = Lighting.OutdoorAmbient
local original_brightness = Lighting.Brightness
local original_exposure = Lighting.ExposureCompensation
EnvironmentSection.CreateToggle({
    Name = "Full Bright",
    Default = false,
    Callback = function(state)
        full_bright_enabled = state
        if full_bright_enabled then
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 3
            Lighting.ExposureCompensation = 1
        else
            Lighting.Ambient = original_ambient
            Lighting.OutdoorAmbient = original_outdoor_ambient
            Lighting.Brightness = original_brightness
            Lighting.ExposureCompensation = original_exposure
        end
    end,
})

-- Feature: Time of Day Slider
EnvironmentSection.CreateSlider({
    Name = "Time of Day",
    Range = {0, 24},
    Increment = 0.1,
    Suffix = " hours",
    CurrentValue = Lighting:GetMinutesAfterMidnight() / 60,
    Callback = function(value)
        Lighting:SetMinutesAfterMidnight(value * 60)
    end,
})

-- Section: Tracers
local TracerSection = VisualsTab.CreateSection("Tracers")

local tracer_active = false
local tracer_lines = {}
local tracer_connection = nil

local function create_tracer(target_player)
    local line = Instance.new("Part")
    line.BrickColor = BrickColor.new("Bright yellow")
    line.Material = Enum.Material.Neon
    line.Anchored = true
    line.CanCollide = false
    line.Transparency = 0.5
    line.Size = Vector3.new(0.1, 0.1, 0.1)
    line.Parent = Workspace.CurrentCamera -- Parent to camera for consistent rendering
    line.Name = "PlayerTracer_" .. target_player.Name
    table.insert(tracer_lines, line)
    return line
end

TracerSection.CreateToggle({
    Name = "Player Tracers",
    Default = false,
    Callback = function(state)
        tracer_active = state
        if tracer_connection then tracer_connection:Disconnect() end

        for _, line in pairs(tracer_lines) do
            line:Destroy()
        end
        tracer_lines = {}

        if tracer_active then
            tracer_connection = RunService.RenderStepped:Connect(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local root_part = player.Character.HumanoidRootPart
                        local screen_pos, on_screen = Workspace.CurrentCamera:WorldToScreenPoint(root_part.Position)
                        
                        -- Tracers from bottom-center of screen to player
                        local start_world = Workspace.CurrentCamera.CFrame.Position
                        local end_world = root_part.Position
                        local distance = (start_world - end_world).magnitude

                        local tracer_line = nil
                        for _, line in pairs(tracer_lines) do
                            if line.Name == "PlayerTracer_" .. player.Name then
                                tracer_line = line
                                break
                            end
                        end
                        if not tracer_line then
                            tracer_line = create_tracer(player)
                        end

                        tracer_line.CFrame = CFrame.new(start_world, end_world) * CFrame.new(0, 0, -distance / 2)
                        tracer_line.Size = Vector3.new(0.1, 0.1, distance)
                        tracer_line.Parent = Workspace -- Important: Must be in Workspace for 3D rendering
                    else
                        -- Remove tracer if player is invalid or off screen
                        for i = #tracer_lines, 1, -1 do
                            local line = tracer_lines[i]
                            if line.Name == "PlayerTracer_" .. player.Name then
                                line:Destroy()
                                table.remove(tracer_lines, i)
                            end
                        end
                    end
                end

                -- Clean up tracers for players who left
                for i = #tracer_lines, 1, -1 do
                    local line = tracer_lines[i]
                    local player_name_from_tracer = string.match(line.Name, "PlayerTracer_(.+)")
                    if not Players:FindFirstChild(player_name_from_tracer) then
                        line:Destroy()
                        table.remove(tracer_lines, i)
                    end
                end
            end)
        end
    end,
})

-- ============================================================================
-- 9. Utility Tab Features
-- ============================================================================

-- Section: Teleports
local TeleportSection = UtilityTab.CreateSection("Teleports")

-- Feature: Teleport to Mouse
TeleportSection.CreateButton({
    Name = "Teleport to Mouse",
    Callback = function()
        local mouse = LocalPlayer:GetMouse()
        local hit_pos = mouse.Hit.Position
        if LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart then
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(hit_pos + Vector3.new(0, 5, 0))
            Notify({
                Title = "Teleported!",
                Content = "Teleported to mouse position.",
                Duration = 3,
                Image = "rbxassetid://540417643",
            })
        end
    end,
})

-- Feature: Teleport to Player (Textbox)
local get_player_teleport_name = TeleportSection.CreateTextBox({
    Name = "Player Name",
    Placeholder = "Enter player name...",
    Text = "",
    Callback = function(text)
        -- Value is automatically stored in UI_STATE["Player Name"] by CreateTextBox
    end,
})

TeleportSection.CreateButton({
    Name = "Teleport to Player",
    Callback = function()
        local player_name = get_player_teleport_name()
        if not player_name or player_name == "" then
            Notify({
                Title = "Error",
                Content = "Please enter a player name to teleport to.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
            return
        end

        local target_player = Players:FindFirstChild(player_name)
        if target_player and target_player.Character and target_player.Character:FindFirstChild("HumanoidRootPart") then
            if LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart then
                LocalPlayer.Character.HumanoidRootPart.CFrame = target_player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
                Notify({
                    Title = "Teleported!",
                    Content = "Teleported to " .. target_player.Name .. ".",
                    Duration = 3,
                    Image = "rbxassetid://540417643",
                })
            end
        else
            Notify({
                Title = "Error",
                Content = "Player not found or character not loaded.",
                Duration = 5,
                Image = "rbxassetid://6253457193",
            })
        end
    end,
})

-- Section: General Utility
local GeneralUtilitySection = UtilityTab.CreateSection("General Utility")

-- Feature: Anti-AFK Toggle
local anti_afk_enabled = false
local anti_afk_connection = nil
GeneralUtilitySection.CreateToggle({
    Name = "Anti-AFK",
    Default = false,
    Callback = function(state)
        anti_afk_enabled = state
        if anti_afk_connection then anti_afk_connection:Disconnect() end
        if anti_afk_enabled then
            anti_afk_connection = RunService.Heartbeat:Connect(function()
                if LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid:Move(Vector3.new(0.01, 0, 0))
                    task.wait(0.1)
                    LocalPlayer.Character.Humanoid:Move(Vector3.new(-0.01, 0, 0))
                end
            end)
        end
    end,
})

-- ============================================================================
-- 10. Fun & Misc Tab Features
-- ============================================================================

-- Section: Particles & Effects
local EffectsSection = FunTab.CreateSection("Particles & Effects")

-- Feature: Client-sided Fire Particles
local fire_particles_enabled = false
local fire_particle_attachment = nil
EffectsSection.CreateToggle({
    Name = "Spawn Fire Particles",
    Default = false,
    Callback = function(state)
        fire_particles_enabled = state
        if fire_particle_attachment then fire_particle_attachment:Destroy() end

        if fire_particles_enabled then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                fire_particle_attachment = Instance.new("Attachment")
                fire_particle_attachment.Parent = LocalPlayer.Character.HumanoidRootPart

                local fire = Instance.new("ParticleEmitter")
                fire.Texture = "rbxassetid://257924844"
                fire.Acceleration = Vector3.new(0, 5, 0)
                fire.Brightness = 2
                fire.Color = ColorSequence.new(Color3.fromRGB(255, 255, 0), Color3.fromRGB(255, 0, 0))
                fire.Drag = 0.05
                fire.Enabled = true
                fire.Lifetime = NumberRange.new(0.5, 1.5)
                fire.LightInfluence = 0.5
                fire.Rate = 100
                fire.Rotation = NumberRange.new(-180, 180)
                fire.RotSpeed = NumberRange.new(-50, 50)
                fire.Size = NumberSequence.new(0.5, 2)
                fire.Speed = NumberRange.new(1, 5)
                fire.SpreadAngle = Vector2.new(90, 90)
                fire.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(0.5, 0.5),
                    NumberSequenceKeypoint.new(1, 1)
                })
                fire.VelocityInheritance = 0.5
                fire.ZOffset = 0
                fire.Parent = fire_particle_attachment
            else
                Notify({
                    Title = "Error",
                    Content = "Character or HumanoidRootPart not found for particles.",
                    Duration = 5,
                })
            end
        end
    end,
})

-- Feature: Client-sided Smoke Particles
local smoke_particles_enabled = false
local smoke_particle_attachment = nil
EffectsSection.CreateToggle({
    Name = "Spawn Smoke Particles",
    Default = false,
    Callback = function(state)
        smoke_particles_enabled = state
        if smoke_particle_attachment then smoke_particle_attachment:Destroy() end

        if smoke_particles_enabled then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                smoke_particle_attachment = Instance.new("Attachment")
                smoke_particle_attachment.Parent = LocalPlayer.Character.HumanoidRootPart

                local smoke = Instance.new("ParticleEmitter")
                smoke.Texture = "rbxassetid://616335129"
                smoke.Acceleration = Vector3.new(0, 2, 0)
                smoke.Brightness = 1
                smoke.Color = ColorSequence.new(Color3.fromRGB(100, 100, 100), Color3.fromRGB(50, 50, 50))
                smoke.Drag = 0.05
                smoke.Enabled = true
                smoke.Lifetime = NumberRange.new(2, 4)
                smoke.LightInfluence = 0.5
                smoke.Rate = 50
                smoke.Rotation = NumberRange.new(-180, 180)
                smoke.RotSpeed = NumberRange.new(-20, 20)
                smoke.Size = NumberSequence.new(1, 5)
                smoke.Speed = NumberRange.new(0.5, 2)
                smoke.SpreadAngle = Vector2.new(45, 45)
                smoke.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0),
                    NumberSequenceKeypoint.new(0.2, 0.2),
                    NumberSequenceKeypoint.new(1, 1)
                })
                smoke.VelocityInheritance = 0.2
                smoke.ZOffset = 0
                smoke.Parent = smoke_particle_attachment
            else
                Notify({
                    Title = "Error",
                    Content = "Character or HumanoidRootPart not found for particles.",
                    Duration = 5,
                })
            end
        end
    end,
})


-- Section: Chat & Audio (Client-sided)
local ChatAudioSection = FunTab.CreateSection("Chat & Audio")

-- Feature: Chat Spammer (Client-sided)
local chat_spam_enabled = false
local get_chat_spam_message = ChatAudioSection.CreateTextBox({
    Name = "Spam Message",
    Placeholder = "Enter message to spam...",
    Text = "Hello from FunHub!",
    Callback = function(text)
        -- Value automatically stored
    end,
})
local get_chat_spam_delay = ChatAudioSection.CreateSlider({
    Name = "Spam Delay",
    Range = {0.1, 10},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = 1,
    Callback = function(value)
        -- Value automatically stored
    end,
})

local chat_spam_thread = nil
ChatAudioSection.CreateToggle({
    Name = "Enable Chat Spammer",
    Default = false,
    Callback = function(state)
        chat_spam_enabled = state
        if chat_spam_thread then task.cancel(chat_spam_thread) end

        if chat_spam_enabled then
            chat_spam_thread = task.spawn(function()
                while chat_spam_enabled do
                    if LocalPlayer.Chatted then
                        LocalPlayer.Chatted:Fire("rbx_local_chat", get_chat_spam_message())
                    end
                    task.wait(get_chat_spam_delay())
                end
            end)
        else
            Notify({
                Title = "Chat Spammer",
                Content = "Chat Spammer Disabled.",
                Duration = 2,
            })
        end
    end,
})

-- Feature: Play Sound Effect (Client-sided)
ChatAudioSection.CreateButton({
    Name = "Play Fun Sound",
    Callback = function()
        local sound_id = "rbxassetid://106579069" -- Example: Default Roblox 'Woosh' sound
        local sound = Instance.new("Sound")
        sound.SoundId = sound_id
        sound.Parent = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or Workspace
        sound.Volume = 0.5
        sound:Play()
        Debris:AddItem(sound, sound.TimeLength + 1)
        Notify({
            Title = "Sound Played!",
            Content = "A fun sound effect has been played.",
            Duration = 3,
        })
    end,
})

-- ============================================================================
-- 11. Settings Tab
-- ============================================================================

local UISettingsSection = SettingsTab.CreateSection("UI Settings")

-- Feature: Toggle UI Visibility
UISettingsSection.CreateButton({
    Name = "Toggle UI (Hide/Show)",
    Callback = function()
        main_frame.Visible = not main_frame.Visible
        is_ui_open = main_frame.Visible
        Notify({
            Title = "UI Toggled",
            Content = "UI is now " .. (is_ui_open and "visible" or "hidden") .. ".",
            Duration = 2,
        })
    end,
})

-- Feature: Destroy UI (Careful with this!)
UISettingsSection.CreateButton({
    Name = "Destroy UI",
    Callback = function()
        Notify({
            Title = "Destroying UI...",
            Content = "The FunHub UI will be destroyed.",
            Duration = 3,
            Image = "rbxassetid://6253457193",
        })
        task.wait(0.5)
        main_screen_gui:Destroy()
    end,
})

-- ============================================================================
-- 12. Final Initializations & Callbacks
-- ============================================================================

-- Restore initial states if character respawns (for walkspeed, jumppower, godmode)
LocalPlayer.CharacterAdded:Connect(function(char)
    -- Re-apply walkspeed if slider was used
    local ws_val = get_walkspeed_value()
    if ws_val then
        char:WaitForChild("Humanoid").WalkSpeed = ws_val
    end
    -- Re-apply jumppower if slider was used
    local jp_val = get_jumppower_value()
    if jp_val then
        char:WaitForChild("Humanoid").JumpPower = jp_val
    end
    -- Re-apply godmode visual if enabled
    if godmode_enabled then
        char:WaitForChild("Humanoid").MaxHealth = math.huge
        char:WaitForChild("Humanoid").Health = char:WaitForChild("Humanoid").MaxHealth
    end
    -- Noclip reconnect (important for keeping it active after death)
    if noclip_enabled then
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CollisionGroup = "NoCollision"
            end
        end
        if not noclip_connection then -- Re-establish connection if it was lost
            noclip_connection = RunService.Stepped:Connect(function()
                if noclip_enabled and LocalPlayer.Character and LocalPlayer.Character.Humanoid then
                    LocalPlayer.Character.Humanoid.PlatformStand = true
                end
            end)
        end
    end
end)

-- Set the initial active tab
SetActiveTab("Player")

-- Initial notification that the script is loaded
Notify({
    Title = "FunHub Custom UI Loaded!",
    Content = "The custom UI script has been successfully loaded. Enjoy!",
    Duration = 5,
    Image = "rbxassetid://4655452243",
})

-- ============================================================================
-- Script End
-- ============================================================================
